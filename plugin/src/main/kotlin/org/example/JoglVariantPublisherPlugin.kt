/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.gradle.api.Project
import org.gradle.api.Plugin
import java.io.File
import java.io.RandomAccessFile
import java.sql.DriverManager

/**
 * A simple 'hello world' plugin.
 */
class JoglVariantPublisherPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Register a task
        project.tasks.register("greeting") { task ->
            task.doLast {
                println("Hello from plugin 'org.example.greeting'")
            }
        }
    }
}

fun main() {
    val profilePath = "/home/elect/snap/firefox/common/.mozilla/firefox/hf0wm7ar.default"
    //    val cookieName = "cookieName"

    val cookieDb = File(profilePath, "cookies.sqlite")

    // Check if Firefox is running
    //    val parentLock = File(profilePath, "parent.lock")
    //    require(parentLock.exists()) { "Firefox is currently running. Please close it first." }

    // Check if the database exists
    require(cookieDb.exists()) { "Cookie database not found at: ${cookieDb.absolutePath}" }

    // Create backup
    val backup = File(profilePath, "cookies.sqlite.backup")
    cookieDb.copyTo(backup, overwrite = true)

    // Read the file directly instead of using SQL
    RandomAccessFile(cookieDb, "r").use { file ->
        // Read the first few bytes to verify it's an SQLite database
        val header = ByteArray(16)
        file.read(header)
        val isSqlite = String(header).startsWith("SQLite format 3")
        require(isSqlite) { "The file is not a valid SQLite database" }
    }

    println("$cookieDb locked: " + isDatabaseLocked(cookieDb))
    println("$backup locked: " + isDatabaseLocked(backup))

    //    DriverManager.getConnection("jdbc:sqlite:${backup.path}").use { conn ->
    //        conn.createStatement().use { stmt ->
    //            // Try a simple read operation
    //            stmt.executeQuery("SELECT 1").use { rs ->
    //                rs.next() // Actually try to read
    //            }
    //        }
    //    }

    // List cookies for a specific domain
    for (domain in listOf("mcas.ms", "microsoftonline.com", "live.com")) {
        println("\nCookies for domain '$domain':")
        val deleted = deleteCookies(backup, domainFilter = domain)
        println("deleted $deleted cookies")
    }
    backup.copyTo(cookieDb, overwrite = true)
}

fun isDatabaseLocked(cookieDb: File): Boolean =
    try {
        RandomAccessFile(cookieDb, "rw").use { file ->
            file.channel.use { channel ->
                // Try to get an exclusive lock
                val locked = channel.tryLock()
                if (locked != null) {
                    locked.release()
                    false
                } else true
            }
        }
    } catch (e: Exception) {
        // If we can't even open the file, consider it locked
        true
    }

fun deleteCookies(dbFile: File, domainFilter: String? = null, nameFilter: String? = null): Int {

    require(!isDatabaseLocked(dbFile)) { "Database is locked. Make sure Firefox is not running." }

    DriverManager.getConnection("jdbc:sqlite:${dbFile.absolutePath}").use { conn ->
        conn.createStatement().use { stmt ->
            val whereClause = buildString {
                if (domainFilter != null || nameFilter != null) {
                    append(" WHERE ")
                    val conditions = buildList {
                        domainFilter?.let {
                            add("""(
                                host LIKE '%$it%' OR 
                                host LIKE '.$it' OR 
                                host LIKE '%.$it' OR 
                                host = '$it'
                            )""".trimIndent()
                               )
                        }
                        nameFilter?.let { add("name LIKE '%$it%'") }
                    }
                    append(conditions.joinToString(" AND "))
                }
            }

            // First, let's see what domains we actually have
            val debugQuery = "SELECT DISTINCT host FROM moz_cookies WHERE host LIKE '%$domainFilter%'"
            println("Available domains:")
            stmt.executeQuery(debugQuery).use { rs ->
                while (rs.next())
                    println("  - ${rs.getString("host")}")
            }

            val deleteQuery = "DELETE FROM moz_cookies$whereClause"
            return stmt.executeUpdate(deleteQuery)
        }
    }
}
